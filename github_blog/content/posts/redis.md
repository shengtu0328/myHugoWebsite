---
title: "Redis"
date: 2022-12-30T18:00:43+08:00
draft: true
---

## 1.缓存穿透

缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。

常见的解决方案有两种：

缓存空对象

优点：实现简单，维护方便

缺点：额外的内存消耗可能造成短期的不一致

布隆过滤 :

优点：内存占用较少，没有多余key

缺点：实现复杂存在误判可能



增强id的复杂度，避免被猜测id

规律做好数据的基础格式校验

加强用户权限校验

做好热点参数的限流




## 2.缓存雪崩

解决方案：给不同的Key的TTL添加随机值利

用Redis集群提高服务的可用性

给缓存业务添加降级限流策略

给业务添加多级缓存
## 3.缓存击穿

缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击

1.互斥锁

2.逻辑过期 （不设置ttl，这是多存了一个expire的字段，能够确保redis中始终有这个缓存)





Cache Aside的模式选择
	更新缓存还是删除缓存？
		更新缓存会产生无效更新，并且存在较大的线程安全问题
		删除缓存本质是延迟更新，没有无效更新，线程安全问题相对较低
	先操作数据库还是缓存？
		先更新数据，再删除缓存
			在满足原子性的情况下，安全问题概率较低
		先删除缓存，再更新数据库
			安全问题概率较高
	如何确保数据库与缓存操作原子性？
		单体系统
			利用事务机制
		分布式系统
			利用分布式事务机制



## 4.缓存策略



| 更新操作 种类1（删除缓存）推荐 | 更新操作 种类2（更新缓存）不推荐 | 查询操作                                        |
| ------------------------------ | -------------------------------- | ----------------------------------------------- |
| 1.数据库首先要更新             | 1.数据库首先要更新               | 1.查询缓存     如果有  返回结果↑                |
| 2.缓存执行删除操作             | 2.缓存要执行更新操作             | 2.查询数据库                                    |
|                                |                                  | 3.把数据库查出来的结果更新到缓存      返回结果↑ |
|                                |                                  |                                                 |







## 工作中哪些场景用到了redis？



| 场景                                               | 数据类型                 |
| -------------------------------------------------- | ------------------------ |
| 短信验证码                                         | String                   |
| 分布式系统中统一认证授权管理，用户的信息，权限等。 | Hash？                   |
| 热点商品缓存                                       | Hash?                    |
| 全局唯一id 简单的就如 xrq00001                     | String Incr              |
| 进度条                                             | list push pop            |
| SpringCache？                                      |                          |
| 分布式锁（悲观锁）                                 | setnx                    |
| 点赞 （一个用户一篇文章只能赞一次）                | Set                      |
| 排行榜                                             | sorted Set               |
| 大量用户的每年每天的签到记录，以及连续签到多少天   | BitMap（也是String里的） |
| 统计uv，pv                                         | HyperLogLog              |





| 分布式锁（悲观锁）                                           | 乐观锁 和 mysql行锁                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 比如商品，并且还要限制一人一单。mysql update行锁可以限制不超卖，但是要限制一人一单，并且不用数据库联合列唯一索引的话。就要用到分布式锁 | 数据库 version字段实现                                       |
| 悲观锁是在下单前，就比如一人一单                             | 乐观锁是在update的时候用的，判断有没有被修改过。             |
| 数据库里还没有数据，是在新增数据的时候。                     | 就比如商品开卖前库存表肯定是有记录的，之后减库存执行update stock=stock-1的操作。 |





延时双删

![](延迟双删.png) 







## 秒杀问题

库存防止超卖可以有两种办法实现情况

1. 只需要decr 1， 结果 ＜0 的话成功，否则失败。
2. 需要一个lua脚本，里面包含了2部操作(1.先get 库存，2.如果>0,decr 1)





## List

基于List的消息队列有哪些优缺点？

优点：

利用Redis存储，不受限于JVM内存上限基于Redis的持久化机制，数据安全性有保证可以满足消息有序性

缺点：

无法避免消息丢失只支持单消费者





## PubSub

基于PubSub的消息队列有哪些优缺点？

优点：

采用发布订阅模型，支持多生产、多消费

缺点：

不支持数据持久化无法避免消息丢失消息堆积有上限，超出时数据丢失





## 持久化

### RDB

RDB方式的 bgsave基本流程是什么？

fork主进程得到一个子进程，共享内存空间子进程读取内存数据并写入新的RDB文件用新RDB文件替换旧的RDB文件。

RDB会在什么时候执行？save 60 1000代表什么含义？

默认是服务停止时。代表60秒内至少执行1000次修改则触发RDB



RDB的缺点？

RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险

fork子进程、压缩、写出RDB文件都比较耗时





### AOF

  ![](rdb&aof.png)

## 1.缓存一致性



  ![](先清缓存_后更新数据库.png)

  ![](先更新数据库_后清缓存.png)









#### 删除数据

1.先删缓存   再删数据库

  ![](先删缓存后删数据库.png)

缓存里面有数据， 数据库里面没有数据库



2.先删数据库 再删缓存

  ![](先删数据库后删缓存.png)

缓存里面有数据， 数据库里面没有数据库





#### 更新数据
先更新数据库再更新缓存
  ![](先更新数据库再更新缓存.png)



#### 现在主流的策略都是 先更新数据库 再删除缓存，不建议做更新缓存的操作
 ![](先更新数据库后删除缓存.png)
 ![](先更新数据库后删除缓存-问题.png)


  ![]( 黑马缓存一致性.png)


#### 解决方法（延时双删）在 **先更新数据库 ，后删缓存**的 操作中，可以通过发送mq 进行 延时的删除操作




## 什么样的数据不适合做缓存？

1.不建议去缓冲查询频率不是很高的数据

2.更新次数太多

3.数据要求一致性极高的场景



